{
  "item": [
    {
      "id": "3ecbe953-d9e7-473d-a1a9-e0326d1bc034",
      "name": "TC-001 - Retrieve pets with a valid status: available",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus?status=available",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ],
          "query": [
            {
              "key": "status",
              "value": "available"
            }
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "18330147-c23a-4dc1-ac1d-e10a1ffccd9a",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 200', function () { pm.response.to.have.status(200); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });",
              "pm.test('Response JSON is an array', function () { pm.expect(pm.response.json()).to.be.an('array'); });",
              "pm.test('JSON array min length 1', function () { pm.expect(pm.response.json().length).to.be.at.least(1); });",
              "pm.test('JSON path exists: [0].id', function () { const json = tryParseJson(); pm.expect(json, 'Response body is valid JSON').to.not.eql(undefined); pm.expect(resolvePath(json, \"[0].id\"), 'Path [0].id').to.not.eql(undefined); });"
            ]
          }
        }
      ]
    },
    {
      "id": "f6456d3a-bd3c-4f00-a2a4-1a39e9d91c54",
      "name": "TC-002 - Retrieve pets with a valid status: pending",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus?status=pending",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ],
          "query": [
            {
              "key": "status",
              "value": "pending"
            }
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "4af0a326-2ce5-4d93-976e-3e19ee582844",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 200', function () { pm.response.to.have.status(200); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });",
              "pm.test('Response JSON is an array', function () { pm.expect(pm.response.json()).to.be.an('array'); });",
              "pm.test('JSON array min length 1', function () { pm.expect(pm.response.json().length).to.be.at.least(1); });",
              "pm.test('JSON path exists: [0].id', function () { const json = tryParseJson(); pm.expect(json, 'Response body is valid JSON').to.not.eql(undefined); pm.expect(resolvePath(json, \"[0].id\"), 'Path [0].id').to.not.eql(undefined); });"
            ]
          }
        }
      ]
    },
    {
      "id": "58cabda5-ee0c-4202-b487-8cf356d3ec04",
      "name": "TC-003 - Retrieve pets with a valid status: sold",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus?status=sold",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ],
          "query": [
            {
              "key": "status",
              "value": "sold"
            }
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "fcfca21f-caca-4348-9bdc-3b1ecd4e3858",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 200', function () { pm.response.to.have.status(200); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });",
              "pm.test('Response JSON is an array', function () { pm.expect(pm.response.json()).to.be.an('array'); });",
              "pm.test('JSON array min length 1', function () { pm.expect(pm.response.json().length).to.be.at.least(1); });",
              "pm.test('JSON path exists: [0].id', function () { const json = tryParseJson(); pm.expect(json, 'Response body is valid JSON').to.not.eql(undefined); pm.expect(resolvePath(json, \"[0].id\"), 'Path [0].id').to.not.eql(undefined); });"
            ]
          }
        }
      ]
    },
    {
      "id": "a432b5ac-90e8-45ee-a5a2-0df78ab05462",
      "name": "TC-004 - Retrieve pets with multiple statuses: available,pending",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus?status=available&status=pending",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ],
          "query": [
            {
              "key": "status",
              "value": "available"
            },
            {
              "key": "status",
              "value": "pending"
            }
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "a335cac8-1404-4cfe-81ce-e5f60cb17c03",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 200', function () { pm.response.to.have.status(200); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });",
              "pm.test('Response JSON is an array', function () { pm.expect(pm.response.json()).to.be.an('array'); });",
              "pm.test('JSON array min length 1', function () { pm.expect(pm.response.json().length).to.be.at.least(1); });",
              "pm.test('JSON path exists: [0].id', function () { const json = tryParseJson(); pm.expect(json, 'Response body is valid JSON').to.not.eql(undefined); pm.expect(resolvePath(json, \"[0].id\"), 'Path [0].id').to.not.eql(undefined); });"
            ]
          }
        }
      ]
    },
    {
      "id": "c3b3ccb0-33d4-412a-a6ea-caa0bea6feeb",
      "name": "TC-005 - Retrieve pets with multiple statuses: pending,sold",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus?status=pending&status=sold",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ],
          "query": [
            {
              "key": "status",
              "value": "pending"
            },
            {
              "key": "status",
              "value": "sold"
            }
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "834ba3e9-b67e-4f22-9575-9e5a3dc36dbc",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 200', function () { pm.response.to.have.status(200); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });",
              "pm.test('Response JSON is an array', function () { pm.expect(pm.response.json()).to.be.an('array'); });",
              "pm.test('JSON array min length 1', function () { pm.expect(pm.response.json().length).to.be.at.least(1); });",
              "pm.test('JSON path exists: [0].id', function () { const json = tryParseJson(); pm.expect(json, 'Response body is valid JSON').to.not.eql(undefined); pm.expect(resolvePath(json, \"[0].id\"), 'Path [0].id').to.not.eql(undefined); });"
            ]
          }
        }
      ]
    },
    {
      "id": "70d001d7-f784-475f-a861-e680a9883a14",
      "name": "TC-006 - Missing status returns an empty list",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "faa06cea-ea19-4293-8c98-c9a7487b253f",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 200', function () { pm.response.to.have.status(200); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });",
              "pm.test('Response JSON is an array', function () { pm.expect(pm.response.json()).to.be.an('array'); });",
              "pm.test('JSON array min length 0', function () { pm.expect(pm.response.json().length).to.be.at.least(0); });"
            ]
          }
        }
      ]
    },
    {
      "id": "533efbe8-7dd5-445e-a47a-9c79cf404ad9",
      "name": "TC-007 - Unsupported status is rejected: unknown",
      "request": {
        "url": {
          "raw": "{{baseUrl}}/pet/findByStatus?status=unknown",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "pet",
            "findByStatus"
          ],
          "query": [
            {
              "key": "status",
              "value": "unknown"
            }
          ]
        },
        "method": "GET"
      },
      "response": [],
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "98bca1f4-0e93-49a9-bee5-82e4501429a3",
            "type": "text/javascript",
            "exec": [
              "function resolvePath(obj, path) {",
              "  if (obj === null || obj === undefined) return undefined;",
              "  if (!path || typeof path !== 'string') return undefined;",
              "  // Supports dot notation and array indices like [0].id",
              "  const normalized = path.replace(/\\[(\\d+)\\]/g, '.$1');",
              "  const parts = normalized.split('.').filter(Boolean);",
              "  let cur = obj;",
              "  for (const part of parts) {",
              "    if (cur === null || cur === undefined) return undefined;",
              "    if (Object(cur) !== cur) return undefined;",
              "    cur = cur[part];",
              "  }",
              "  return cur;",
              "}",
              "function tryParseJson() {",
              "  try { return pm.response.json(); } catch (e) { return undefined; }",
              "}",
              "pm.test('Status is 400', function () { pm.response.to.have.status(400); });",
              "pm.test('Header present: Content-Type', function () { pm.expect(pm.response.headers.has(\"Content-Type\")).to.eql(true); });",
              "pm.test('Content-Type includes application/json', function () { pm.expect(pm.response.headers.get('Content-Type') || '').to.include(\"application/json\"); });"
            ]
          }
        }
      ]
    }
  ],
  "event": [],
  "variable": [
    {
      "type": "any",
      "value": "https://petstore.swagger.io/v2",
      "key": "baseUrl"
    },
    {
      "type": "any",
      "value": "",
      "key": "accessToken"
    }
  ],
  "info": {
    "_postman_id": "f1c1df0e-45a9-47dd-a2a6-0d1d74c2df9f",
    "name": "Fetch pets by status",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "description": {
      "content": "Feature: Fetch pets by status\r\n  Background:\r\n    Given the Petstore service is reachable at {{baseUrl}}\r\n\r\n  Scenario Outline: Retrieve pets with a valid status\r\n    # Target URL: {{baseUrl}}/pet/findByStatus\r\n    When I request pets filtered by the status \"<status>\"\r\n    Then the response status code should be 200\r\n    And the response should be a list of pets\r\n    And the listed pets should include their unique identifiers\r\n    And each pet should reflect one of the requested statuses\r\n\r\n    Examples:\r\n      | status    |\r\n      | available |\r\n      | pending   |\r\n      | sold      |\r\n\r\n  Scenario Outline: Retrieve pets with multiple statuses\r\n    # Target URL: {{baseUrl}}/pet/findByStatus\r\n    When I request pets filtered by the statuses \"<statuses>\"\r\n    Then the response status code should be 200\r\n    And the response should be a list of pets\r\n    And the listed pets should include their unique identifiers\r\n    And each pet should reflect one of the requested statuses\r\n\r\n    Examples:\r\n      | statuses            |\r\n      | available,pending   |\r\n      | pending,sold        |\r\n\r\n  Scenario: Missing status returns an empty list\r\n    # Target URL: {{baseUrl}}/pet/findByStatus\r\n    When I request pets without providing any status filter\r\n    Then the response status code should be 200\r\n    And the response should be empty\r\n\r\n  Scenario: Unsupported status is rejected\r\n    # Target URL: {{baseUrl}}/pet/findByStatus\r\n    When I request pets filtered by an unsupported status value\r\n    Then the response status code should be 400\r\n    And the request should be rejected",
      "type": "text/plain"
    }
  }
}